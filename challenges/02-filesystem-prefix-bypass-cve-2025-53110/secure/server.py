"""Challenge 02 - Secure MCP server that patches CVE-2025-53110."""
from __future__ import annotations

import logging
import os
from typing import List

from mcp.server.fastmcp import FastMCP

APP_NAME = "Challenge 02: Filesystem Prefix Bypass (Secure)"
INSTRUCTIONS = (
    "Expose a hardened directory listing tool confined to /app/files/safe_files. "
    "Resolve paths securely and refuse access outside that directory."
)
ALLOWED_DIR = "/app/files/safe_files"

log = logging.getLogger("challenge02.secure")

mcp = FastMCP(
    name=APP_NAME,
    instructions=INSTRUCTIONS,
    streamable_http_path="/mcp/stream",
)
mcp.app = mcp.streamable_http_app()


def _resolve_allowed_dir() -> str:
    """Allow tests to override the allowed directory via env or monkey patching."""
    return os.environ.get("CHALLENGE02_ALLOWED_DIR", ALLOWED_DIR)


def _format_entries(full_path: str, entries: List[str]) -> str:
    listing = "\n".join(entries) or "(empty)"
    return f"Listing for {full_path}:\n{listing}"


def _is_path_within_allowed(real_allowed_dir: str, real_target: str) -> bool:
    try:
        common_prefix = os.path.commonpath([real_allowed_dir, real_target])
    except ValueError:
        return False
    return common_prefix == real_allowed_dir


@mcp.tool()
def list_directory_contents(full_path: str) -> str:
    """Secure directory listing that validates containment via realpath/commonpath."""
    # Input sanitization
    if not full_path or not isinstance(full_path, str):
        return "Invalid path: path must be a non-empty string."
    
    full_path = full_path.strip()
    if not full_path:
        return "Invalid path: path must be a non-empty string."
    
    allowed_dir = _resolve_allowed_dir()
    real_allowed_dir = os.path.realpath(allowed_dir)
    
    # Check if target exists before resolving (prevents misleading error messages)
    if not os.path.exists(full_path):
        log.warning("Blocked attempt to access non-existent path: %s", full_path)
        return "Access denied."
    
    # Resolve real path - this handles symlinks, .., and other traversal attempts
    # SECURITY: realpath() resolves symlinks, preventing symlink-based directory escapes
    real_target = os.path.realpath(full_path)
    
    if not _is_path_within_allowed(real_allowed_dir, real_target):
        log.warning("SECURITY: Blocked directory traversal attempt: %s (resolved to %s)", 
                   full_path, real_target)
        return "Access denied."
    
    if not os.path.isdir(real_target):
        return "Access denied."

    try:
        entries = sorted(os.listdir(real_target))
    except PermissionError:
        log.warning("Permission denied when accessing %s", real_target)
        return "Access denied."

    log.info("Listing directory %s (allowed base %s)", real_target, real_allowed_dir)
    return _format_entries(real_target, entries)


if __name__ == "__main__":
    import uvicorn

    logging.basicConfig(
        level=os.environ.get("LOG_LEVEL", "WARNING").upper(),
        format="[%(asctime)s] %(levelname)s %(name)s: %(message)s",
    )
    host = os.environ.get("CHALLENGE_HOST", "0.0.0.0")
    port = int(os.environ.get("CHALLENGE_PORT", "8000"))
    
    # Set our logger to WARNING to ensure security events are captured
    log.setLevel(logging.WARNING)
    
    log.warning(
        "Starting secure filesystem MCP server on %s:%s (allowed=%s)",
        host,
        port,
        _resolve_allowed_dir(),
    )
    uvicorn.run("server:mcp.app", host=host, port=port, log_level="info")
