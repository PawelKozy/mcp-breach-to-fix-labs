"""Challenge 02 - Secure MCP server that patches CVE-2025-53110."""
from __future__ import annotations

import logging
import os
from typing import List

from mcp.server.fastmcp import FastMCP

APP_NAME = "Challenge 02: Filesystem Prefix Bypass (Secure)"
INSTRUCTIONS = (
    "Expose a hardened directory listing tool confined to /app/files/safe_files. "
    "Resolve paths securely and refuse access outside that directory."
)
ALLOWED_DIR = "/app/files/safe_files"

log = logging.getLogger("challenge02.secure")

mcp = FastMCP(
    name=APP_NAME,
    instructions=INSTRUCTIONS,
    streamable_http_path="/mcp/stream",
)
mcp.app = mcp.streamable_http_app()


def _resolve_allowed_dir() -> str:
    """Allow tests to override the allowed directory via env or monkey patching."""
    return os.environ.get("CHALLENGE02_ALLOWED_DIR", ALLOWED_DIR)


def _format_entries(full_path: str, entries: List[str]) -> str:
    listing = "\n".join(entries) or "(empty)"
    return f"Listing for {full_path}:\n{listing}"


def _is_path_within_allowed(real_allowed_dir: str, real_target: str) -> bool:
    try:
        common_prefix = os.path.commonpath([real_allowed_dir, real_target])
    except ValueError as e:
        # ValueError occurs when paths are on different drives (Windows) or 
        # mixing absolute/relative paths - both are suspicious
        log.error("SECURITY: commonpath failed for allowed=%s vs target=%s: %s",
                  real_allowed_dir, real_target, e)
        return False
    return common_prefix == real_allowed_dir


@mcp.tool()
def list_directory_contents(full_path: str) -> str:
    """Secure directory listing that validates containment via realpath/commonpath."""
    # Input sanitization
    if not full_path or not isinstance(full_path, str):
        return "Invalid path: path must be a non-empty string."
    
    full_path = full_path.strip()
    if not full_path:
        return "Invalid path: path must be a non-empty string."
    
    allowed_dir = _resolve_allowed_dir()
    real_allowed_dir = os.path.realpath(allowed_dir)
    
    # Resolve real path - this handles symlinks, .., and other traversal attempts
    # SECURITY: realpath() resolves symlinks and canonicalizes paths even if target doesn't exist
    real_target = os.path.realpath(full_path)
    
    if not _is_path_within_allowed(real_allowed_dir, real_target):
        log.warning("SECURITY: Blocked directory traversal attempt: %s (resolved to %s)", 
                   full_path, real_target)
        return "Access denied."
    
    # Now verify target exists and is a directory
    if not os.path.exists(real_target):
        log.warning("Blocked attempt to access non-existent path: %s", full_path)
        return "Access denied."
    
    if not os.path.isdir(real_target):
        return "Access denied."

    try:
        entries = sorted(os.listdir(real_target))
    except PermissionError:
        log.warning("Permission denied when accessing %s", real_target)
        return "Access denied."

    log.info("Listing directory %s (allowed base %s)", real_target, real_allowed_dir)
    return _format_entries(real_target, entries)


@mcp.tool()
def read_file_contents(file_path: str) -> str:
    """Securely read file contents with path containment validation.
    
    Applies the same security controls as list_directory_contents:
    - Path canonicalization via realpath()
    - Containment validation via commonpath()
    - Symlink detection
    """
    # Input sanitization
    if not file_path or not isinstance(file_path, str):
        return "Invalid path: path must be a non-empty string."
    
    file_path = file_path.strip()
    if not file_path:
        return "Invalid path: path must be a non-empty string."
    
    allowed_dir = _resolve_allowed_dir()
    real_allowed_dir = os.path.realpath(allowed_dir)
    
    # Resolve real path
    real_target = os.path.realpath(file_path)
    
    if not _is_path_within_allowed(real_allowed_dir, real_target):
        log.warning("SECURITY: Blocked file read attempt outside allowed dir: %s (resolved to %s)",
                   file_path, real_target)
        return "Access denied."
    
    # Verify target exists and is a regular file (not directory or symlink)
    if not os.path.exists(real_target):
        log.warning("Blocked attempt to read non-existent file: %s", file_path)
        return "Access denied."
    
    if os.path.islink(real_target):
        log.warning("SECURITY: Blocked attempt to read symlink: %s", file_path)
        return "Access denied."
    
    if not os.path.isfile(real_target):
        return "Access denied."
    
    try:
        with open(real_target, 'r', encoding='utf-8') as f:
            content = f.read()
        log.info("Read file %s (allowed base %s)", real_target, real_allowed_dir)
        return content
    except PermissionError:
        log.warning("Permission denied when reading %s", real_target)
        return "Access denied."
    except UnicodeDecodeError:
        return "Error: File is not valid UTF-8 text."
    except Exception as e:
        log.error("Error reading file %s: %s", real_target, e)
        return "Access denied."


if __name__ == "__main__":
    import uvicorn

    logging.basicConfig(
        level=os.environ.get("LOG_LEVEL", "WARNING").upper(),
        format="[%(asctime)s] %(levelname)s %(name)s: %(message)s",
    )
    host = os.environ.get("CHALLENGE_HOST", "0.0.0.0")
    port = int(os.environ.get("CHALLENGE_PORT", "8000"))
    
    # Set our logger to WARNING to ensure security events are captured
    log.setLevel(logging.WARNING)
    
    log.warning(
        "Starting secure filesystem MCP server on %s:%s (allowed=%s)",
        host,
        port,
        _resolve_allowed_dir(),
    )
    uvicorn.run("server:mcp.app", host=host, port=port, log_level="info")
